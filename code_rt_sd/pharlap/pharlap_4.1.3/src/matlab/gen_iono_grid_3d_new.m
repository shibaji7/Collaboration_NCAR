%
% Name :
%   gen_iono_grid_3d.m
%
% Purpose :
%   Generates ionospheric plasma density, collision frequency and irregularity
%   grid as a function of range and height using IRI. Gridded geomagnetic
%   field data (generated using IGRF) is also returned. The format of the
%   outputs is that required for input into the 3d raytracing engine.
%
% Calling sequence :
%   1. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
%         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
%                          doppler_flag)
%
%   2. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
%         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
%                          doppler_flag, profile_type)
%
%   3. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
%         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
%                          doppler_flag, profile_type)
%
% Inputs :
%   UT                - 5x1 array containing UTC date and time - year, month,
%                         day, hour, minute
%   R12               - R12 index
%   iono_grid_parms   - 9x1 vector containing the parameters which define the
%                       ionospheric grid :
%           (1) geodetic latitude (degrees) start
%           (2) latitude step (degrees)
%           (3) number of latitudes
%           (4) geodetic longitude (degrees) start
%           (5) lonitude step (degrees)
%           (6) number of longitudes
%           (7) geodetic height (km) start
%           (8) height step (km)
%           (9) number of heights
%
%   geomag_grid_parms - 9x1 vector containing the parameters which define the
%                       geomagnetic grid :
%           (1) geodetic latitude (degrees) start
%           (2) latitude step (degrees)
%           (3) number of latitudes
%           (4) geodetic lonitude (degrees) start
%           (5) lonitude step (degrees)
%           (6) number of longitudes
%           (7) geodetic height (km) start
%           (8) height step (km)
%           (9) number of heights
%
%   doppler_flag      - flag to indicate whether (=1) or not (=0) to generate
%                       necessary parameters for Doppler shift and spread
%                       calculations in the raytracing routines. NB turning
%                       this on will increase the time required to generate
%                       the ionosphere.
%
% Optional Inputs
%   profile_type      - specify how the ionospheric profiles (with height) are
%                       to be generated (default is 'iri') (see also Notes) :
%      'iri'           = profiles are those generated by the IRI2012 model
%      'iri2016'       = profiles are those generated by the IRI2016 model
%      'iri2012'       = profiles are those generated by the IRI2012 model
%      'iri2007'       = profiles are those generated by the IRI2007 model
%      'firi'          = profiles are those generated by the IRI2012 model
%                        using the FIRI data for heights below 120 km, with
%                        interpolation between FIRI and IRI F layer
%      'chapman'       = profiles generated using IRI2012 layer parameters and
%                        Chapman layers
%      'chapman_fllhc' = as for 'chapman' but the FIRIC low latitude height
%                        correction has been applied
%
%   iri_options        - structure which specfies options for IRI2016 (see 
%                        iri2016.m for details). iri_options is ignored if a
%                        profile_type other than IRI2016 is specified.
%
% Outputs :
%   iono_pf_grid   - 3d grid (height vs lat. vs lon.) of ionospheric plasma
%                      frequency (MHz)
%   iono_pf_grid_5 - 3d grid (height vs lat. vs lon.) of ionospheric plasma
%                      frequency (MHz) 5 minutes later
%   collison_freq  - 3d grid (height vs lat. vs lon.) of ionospheric
%                      collision frequencies
%   Bx             - 3d grid of x component of geomagnetic field
%   By             - 3d grid of y component of geomagnetic field
%   Bz             - 3d grid of z component of geomagnetic field
%
% Notes:
%   1. If an iri2012 profile is requested, then iri2012 is called with the
%   following inputs: B0B1_model = 2 (B0 thickness and B1 shape parameters
%   determined by Bil-2000 model), D_model = 1 (IRI-1990 model for D layer).
%   See iri2012.m for further detail
%
%   2. If an iri2007 profile is requested, then iri2007 is called with the
%   following inputs: B0 - Table option, D-region model - IRI-1995. See
%   iri2007.m for further detail.

%
% Dependencies:
%   iri2016.mex
%   iri2012.mex
%   iri2007.mex
%   igrf2016.mex
%   igrf2011.mex
%   igrf2007.mex
%   solar_za.m
%   chapman.m
%
% Modification History:
%   V1.0  M.A. Cervera  25/06/2010
%     Initial Version
%
%   V1.1  M.A. Cervera  12/09/2012
%     Updated to use IRI2012 and IGRF2011
%
%   V1.2  M.A. Cervera  03/05/2016
%     Updated to use IRI2016 and IGRF2016
%

function [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
    gen_iono_grid_3d_new(UT, R12, iono_grid_parms, geomag_grid_parms, ...
                     doppler_flag, profile_type, varargin)
    
    
    pfsq_conv = 80.6163849431291e-12;  % multiplicative factor to convert 
                                       % electron dens (m^3) to 
				       % plasma freq. squared (MHz^2)
    
    % get the iri_options structure if it has been input
    if (length(varargin) > 0) 
      iri_options = varargin{1};
    else
      iri_options = struct;
    end
				       
    % make sure we have a valid profile type
    if (~exist('profile_type'))
        profile_type = 'iri';
    end
    if (~strcmp(lower(profile_type), 'chapman_fllhc') && ...
            ~strcmp(lower(profile_type), 'chapman') && ...
            ~strcmp(lower(profile_type), 'iri') && ...
	    ~strcmp(lower(profile_type), 'iri2016')  & ...
            ~strcmp(lower(profile_type), 'iri2012') && ...
            ~strcmp(lower(profile_type), 'iri2007') && ...
	    ~strcmp(lower(profile_type), 'firi') )
        error('invalid profile type')
        return
    end
    fllhc_flag = 0;
    if (strcmp(lower(profile_type), 'chapman_fllhc'))
        profile_type = 'chapman';
        fllhc_flag = 1;
    end
    
    % ionospheric and geomagnetic grid definition
    lat_min = iono_grid_parms(1);
    lat_inc = iono_grid_parms(2);
    num_lat = iono_grid_parms(3);
    lon_min = iono_grid_parms(4);
    lon_inc = iono_grid_parms(5);
    num_lon = iono_grid_parms(6);
    ht_min = iono_grid_parms(7);
    ht_inc = iono_grid_parms(8);
    num_ht = iono_grid_parms(9);
    
    B_lat_min = geomag_grid_parms(1);
    B_lat_inc = geomag_grid_parms(2);
    B_num_lat = geomag_grid_parms(3);
    B_lon_min = geomag_grid_parms(4);
    B_lon_inc = geomag_grid_parms(5);
    B_num_lon = geomag_grid_parms(6);
    B_ht_min = geomag_grid_parms(7);
    B_ht_inc = geomag_grid_parms(8);
    B_num_ht = geomag_grid_parms(9);
    
    % initialize arrays
    iono_pf_grid = zeros(num_lat, num_lon, num_ht) .* NaN;
    iono_pf_grid_5 = zeros(num_lat, num_lon, num_ht) .* NaN;
    collision_freq = zeros(num_lat, num_lon, num_ht) .* NaN;
    Bx = zeros(B_num_lat, B_num_lon, B_num_ht);
    By = zeros(B_num_lat, B_num_lon, B_num_ht);
    Bz = zeros(B_num_lat, B_num_lon, B_num_ht);
    
      
    %
    % generate ionospheric grids
    %
    lat_max = lat_min + (num_lat - 1) .* lat_inc;
    lon_max = lon_min + (num_lon - 1) .* lon_inc;
    ht_max = ht_min + (num_ht - 1) .* ht_inc;
    height_arr = [ht_min : ht_inc : ht_max];
    lat_idx = 0;
    for lat_idx = 1:num_lat
        lat = lat_min + (lat_idx - 1) .* lat_inc;
        
        % generate ionosphere gridded in longitude and height
        [iono_pf_subgrid, iono_pf_subgrid_5, collision_freq_subgrid] = gen_iono_subgrid(lat, lon_min, lon_inc, lon_max, ...
               ht_min, ht_inc, ht_max, R12, UT, profile_type, doppler_flag, ...
               iri_options, fllhc_flag);
        
        % populate the ionospheric (lat,lon,height) grids
        iono_pf_grid(lat_idx, :, :) = iono_pf_subgrid;
        iono_pf_grid_5(lat_idx, :, :) = iono_pf_subgrid_5;
        collision_freq(lat_idx, :, :) = collision_freq_subgrid;
        
    end
    
      
    return
end


%
% subfunction which generates ionospheric data gridded over longitude and
% height for a given input latitude
%
function [iono_pf_subgrid, iono_pf_subgrid_5, collision_freq_subgrid] = ...
    gen_iono_subgrid(lat, lon_min, lon_inc, lon_max, ht_min, ht_inc, ...
                     ht_max, R12, UT, profile_type, doppler_flag, ...
                     iri_options, fllhc_flag);
    
    pfsq_conv = 80.6163849431291e-12;    % multiplicative factor to convert 
                                         % electron dens (m^3) to 
					 % plasma freq. squared (MHz^2)
    
    height_arr = [ht_min : ht_inc : ht_max];
    
    % UT 5 minutes later
    UT_5 = UT + [0 0 0 0 5];
    if (UT_5(5) > 59)
        UT_5(5) = UT_5(5) - 60;
        UT_5(4) = UT_5(4) + 1;
        if (UT_5(4) > 23) UT_5(4) = 0; end
    end

    lon_idx = 0;
    for lon = lon_min:lon_inc:lon_max
        lon_idx = lon_idx + 1;
        
        if strcmp(lower(profile_type), 'chapman')
            % call IRI2016 at time UT and 5 minutes later
            [iono, iono_extra] = iri2016(lat, lon, R12, UT);
            if doppler_flag
                [iono, iono_extra5] = iri2012(lat, lon, R12, UT_5);
            else
                iono_extra5 = iono_extra;
            end
            
            % layer critical frequencies and heights
            foE  = sqrt(iono_extra(5) .* pfsq_conv);
            foE_5  = sqrt(iono_extra5(5) .* pfsq_conv);
            hmE  = iono_extra(6);    hmE_5  = iono_extra5(6);
            if (iono_extra(3) == -1)
                foF1 = 0;
                hmF1 = 0;
            else
                foF1 = sqrt(iono_extra(3) .* pfsq_conv);
                hmF1 = iono_extra(4);
            end
            if (iono_extra5(3) == -1)
                foF1_5 = 0;
                hmF1_5 = 0;
            else
                foF1_5 = sqrt(iono_extra5(3) .* pfsq_conv);
                hmF1_5 = iono_extra5(4);
            end
            foF2 = sqrt(iono_extra(1) .* pfsq_conv);
            foF2_5 = sqrt(iono_extra5(1) .* pfsq_conv);
            hmF2 = iono_extra(2);    hmF2_5 = iono_extra5(2);
            
            % apply low latitude height correction to hmF2 a la FIRIC if 
	    % requested
            if fllhc_flag
                fac = exp(-(lat./35).^4);
                hmF2 = hmF2 .* (1 - fac) + fac.*hmF2.*(1 + 0.0015.*(hmF2-300));
                hmF2_5 = hmF2_5 .* (1 - fac) + ...
		         fac.*hmF2_5.*(1 + 0.0015.*(hmF2_5-300));
            end
            
            % layer thicknesses - IRI does not return these values - use 
	    % FIRIC model
            ymE  = 20.0;             ymE_5  = 20.0;
            ymF1 = hmF1 ./ 4;        ymF1_5 = hmF1_5 ./ 4;
            sol_zen_ang = solar_za(lat, lon, UT);
            sol_zen_ang_5 = solar_za(lat, lon, UT);
            SZA_term = 0.15 .* exp(-(sol_zen_ang./105).^4) + 0.25;
            SZA_term_5 = 0.15 .* exp(-(sol_zen_ang_5./105).^4) + 0.25;
            ymF2 = SZA_term .* hmF2;
            ymF2_5 = SZA_term_5 .* hmF2_5;
            
            % generate plasma density profile and fill the array
            iono_pf_subgrid(lon_idx, :)  = chapman(foE, hmE, ymE, ...
                foF1, hmF1, ymF1, foF2, hmF2, ymF2, height_arr);
            
            % generate plasma density profile for 5 minutes later
            iono_pf_subgrid_5(lon_idx, :) = chapman(foE_5, hmE_5, ymE_5, ...
                foF1_5, hmF1_5, ymF1_5, foF2_5, hmF2_5, ymF2_5, height_arr);
            
            % generate collision frequency grid
            collision_freq_subgrid(lon_idx, :) = 4 .* foE.^4 + ...
                1000 .* exp(-(height_arr - 140) ./ 20);
            
            
        elseif (strcmp(lower(profile_type), 'iri') | ...
                strcmp(lower(profile_type), 'iri2016') )
            
            num_heights = round((ht_max - ht_min)/ht_inc) + 1;
            
            % call IRI2016
            [iono, iono_extra] = iri2016(lat, lon, R12, UT, ht_min, ...
                ht_inc, num_heights, iri_options);
            
            if doppler_flag
                [iono5, iono_extra5] = iri2016(lat, lon, R12, UT_5, ht_min, ...
                    ht_inc, num_heights, iri_options);
            end
            
            % get the electron density (Num electrons per m^3)
            elec_dens = iono(1, :);
            idx_neg = find(elec_dens == -1);
            elec_dens(idx_neg) = 0;
            
            if doppler_flag
                elec_dens5 = iono5(1, :);
                idx_neg = find(elec_dens5 == -1);
                elec_dens5(idx_neg) = 0;
            end
            
            % calculate plasma frequency (MHz) profile and fill the array
            iono_pf_subgrid(lon_idx, :) = ...
                sqrt(elec_dens .* pfsq_conv);     % (MHz)
            if doppler_flag
                iono_pf_subgrid_5(lon_idx, :) = ...
                    sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
            else
                iono_pf_subgrid_5(lon_idx, :) = ...
                    sqrt(elec_dens .* pfsq_conv);
            end
            
            % generate collision frequency grid
            foE = sqrt(iono_extra(5) .* pfsq_conv);  % Critical freq of E (MHz)
            collision_freq_subgrid(lon_idx, :) = 4 .* foE.^4 + ...
                1000 .* exp(-(height_arr - 140) ./ 20);
            
        elseif strcmp(lower(profile_type), 'firi')
            
            num_heights = round((ht_max - ht_min)/ht_inc) + 1;
            
            % call IRI 2016, with FIRI option on
            [iono, iono_extra] = ...
	          iri2016_firi_interp(lat, lon, R12, UT, ht_min, ...
		                      ht_inc, num_heights, iri_options);
            
            if doppler_flag
                [iono5, iono_extra5] = ...
		     iri2012_firi(lat, lon, R12, UT_5, ht_min, ht_inc, ...
                                  num_heights, iri_options);
            end
            
            % get the electron density (Num electrons per m^3)
            elec_dens = iono(1, :);
            idx_neg = find(elec_dens == -1);
            elec_dens(idx_neg) = 0;
            
            if doppler_flag
                elec_dens5 = iono5(1, :);
                idx_neg = find(elec_dens5 == -1);
                elec_dens5(idx_neg) = 0;
            end
            
            % calculate plasma frequency (MHz) profile and fill the array
            iono_pf_subgrid(lon_idx, :) = ...
                sqrt(elec_dens .* pfsq_conv);     % (MHz)
            if doppler_flag
                iono_pf_subgrid_5(lon_idx, :) = ...
                    sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
            else
                iono_pf_subgrid_5(lon_idx, :) = ...
                    sqrt(elec_dens .* pfsq_conv);
            end
            
            % generate collision frequency grid
            foE = sqrt(iono_extra(5) .* pfsq_conv);  % Critical freq of E (MHz)
            collision_freq_subgrid(lon_idx, :) = 4 .* foE.^4 + ...
                1000 .* exp(-(height_arr - 140) ./ 20);
            
	  elseif (strcmp(lower(profile_type), 'iri2012') )
	  
            num_heights = round((ht_max - ht_min)/ht_inc) + 1;
            
            % call IRI2012
            [iono, iono_extra] = iri2012(lat, lon, R12, UT, ht_min, ...
                ht_inc, num_heights);
            
            if doppler_flag
                [iono5, iono_extra5] = iri2012(lat, lon, R12, UT_5, ht_min, ...
                    ht_inc, num_heights);
            end
            
            % get the electron density (Num electrons per m^3)
            elec_dens = iono(1, :);
            idx_neg = find(elec_dens == -1);
            elec_dens(idx_neg) = 0;
            
            if doppler_flag
                elec_dens5 = iono5(1, :);
                idx_neg = find(elec_dens5 == -1);
                elec_dens5(idx_neg) = 0;
            end
            
            % calculate plasma frequency (MHz) profile and fill the array
            iono_pf_subgrid(lon_idx, :) = ...
                sqrt(elec_dens .* pfsq_conv);     % (MHz)
            if doppler_flag
                iono_pf_subgrid_5(lon_idx, :) = ...
                    sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
            else
                iono_pf_subgrid_5(lon_idx, :) = ...
                    sqrt(elec_dens .* pfsq_conv);
            end
            
            % generate collision frequency grid
            foE = sqrt(iono_extra(5) .* pfsq_conv);  % Critical freq of E (MHz)
            collision_freq_subgrid(lon_idx, :) = 4 .* foE.^4 + ...
                1000 .* exp(-(height_arr - 140) ./ 20);	  
	  
	  elseif strcmp(lower(profile_type), 'iri2007')
            
            % IRI only returns 100 values for elecron density with height - so
            % determine the number of  multiple calls required.
	    num_ht = (ht_max - ht_min) ./ ht_inc + 1; 
            max_iri_numhts = 100;
            num_iri_calls = ceil(num_ht ./ max_iri_numhts);
            for ii = 1:num_iri_calls
                
                % call IRI 2007
                height_start = ht_min + (ii - 1) .* max_iri_numhts .* ht_inc;
                [iono, iono_extra] = iri2007(lat, lon, R12, UT, height_start, ...
                    ht_inc);
                if doppler_flag
                    [iono5, iono_extra5] = iri2007(lat, lon, R12, UT_5, ...
                        height_start, ht_inc);
                end
                
                % get the electron density (Num electrons per m^3)
                remaining_heights = num_ht - (ii - 1)*max_iri_numhts;
                idx_end = min([remaining_heights max_iri_numhts]);
                
                elec_dens = iono(1, 1:idx_end);
                idx_neg = find(elec_dens == -1);
                elec_dens(idx_neg) = 0;
                
                if doppler_flag
                    elec_dens5 = iono5(1, 1:idx_end);
                    idx_neg = find(elec_dens5 == -1);
                    elec_dens5(idx_neg) = 0;
                end
                
                % calculate plasma frequency (MHz) profile and fill the array
                ht_idx = [(ii - 1)*max_iri_numhts + 1 :  ...
                    ii*max_iri_numhts - (max_iri_numhts - idx_end)];
                iono_pf_subgrid(lon_idx, ht_idx) = ...
                    sqrt(elec_dens .* pfsq_conv);     % (MHz)
                if doppler_flag
                    iono_pf_subgrid_5(lon_idx, ht_idx) = ...
                        sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
                else
                    iono_pf_subgrid_5(lon_idx, ht_idx) = ...
                        sqrt(elec_dens .* pfsq_conv);
                end
                
            end
            
            % generate collision frequency grid
            foE = sqrt(iono_extra(5) .* pfsq_conv);  % Critical freq of E (MHz)
            collision_freq_subgrid(lon_idx, :) = 4 .* foE.^4 + ...
                1000 .* exp(-(height_arr - 140) ./ 20);
            
            
        end
        
    end
    
    return
end
