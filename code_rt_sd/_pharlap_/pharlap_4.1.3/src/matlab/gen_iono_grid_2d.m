%
% Name :
%   gen_iono_grid_2d.m
%
% Purpose :
%   Generates ionospheric plasma density, collision frequency and irregularity
%   grid as a function of range and height using IRI. The format of the
%   outputs is that required for input into the 2d raytracing engine.
%
% Calling sequence :
%   1. [iono_en_grid, iono_en_grid_5, collison_freq, irreg, iono_te_grid] = ...
%         gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, max_range, ...
%                          num_range, range_inc, start_height, height_inc, ...
%                          num_heights, kp, doppler_flag)
%
%   2. [iono_en_grid, iono_en_grid_5, collison_freq, irreg, iono_te_grid] = ...
%         gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, max_range, ...
%                          num_range, range_inc, start_height, height_inc, ...
%                          num_heights, kp, doppler_flag, profile_type)
%
%   3. [iono_en_grid, iono_en_grid_5, collison_freq, irreg, iono_te_grid] = ...
%         gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, max_range, ...
%                          num_range, range_inc, start_height, height_inc, ...
%                          num_heights, kp, doppler_flag, profile_type, ...
%                          iri_options)
%
% *** IMPORTANT NOTE REGARDING INPUTS AND OUTPUTS ***
%
%   1. While the origin lat and long are specified in WGS84 coordinates, the
%   various parameters used to define the various ionospheric and magnetic
%   field grids are *NOT*. Due to the 2D raytracing canonical equations begin
%   specified in Earth centred polar coordinates, raytrace_2d *REQUIRES*
%   these grids to be defined this way. The radial coordinate must be
%   specified as height above a spherical surface of radius *EXACTLY*
%   6378.137 km (the equatorial radius of the Earth). Ground range is the arc
%   length (km) along the spherical surface (defined above) from the origin.
%
% Inputs :
%   origin_lat        - WGS84 geodetic latitude (degrees) of ray origin
%   origin_lon        - WGS84 geodetic longitude (degrees) of ray origin
%   R12               - Yearly smoothed monthly median sunspot number
%   UT                - 5x1 array containing UTC date and time - year, month,
%                         day, hour, minute
%   azim              - azimuth of the desired ionospheric grid from the
%                         origin (degrees from North)
%   max_range         - maximum group range for data grids (Km) (SEE
%                         IMPORTANT NOTE ABOVE)
%   num_range         - number of ranges in iono_pf_grid & bfield grids
%                         (maximum is 2001 ranges)
%   range_inc         - desired range step of iono_pf_grid, bfield, iono_parms,
%                         dec, dip, and irreg_strngth arrays (km) (SEE
%                         IMPORTANT NOTE ABOVE)
%   start_height      - desired start height of iono_pf_grid & bfield grids (km)
%                          (SEE IMPORTANT NOTE ABOVE)
%   height_inc        - desired height step of iono_pf_grid & bfield grids (km)
%                          (SEE IMPORTANT NOTE ABOVE)
%   num_heights       - number of heights in iono_pf_grid & bfield grids
%                          (maximum is 2001 heights)
%   kp                - kp index used for the ionospheric irregularity
%                         strength model in the auroral region. If doppler_flag
%                         (see below) is set to 0 then kp is irrelevant.
%   doppler_flag      - flag to indicate whether (=1) or not (=0) to generate
%                         necessary parameters for Doppler shift and spread
%                         calculations in the raytracing routines. 
%
% Optional Inputs
%   profile_type      - specify out the ionospheric profiles (with height) are
%                       to be generated (default is 'iri'):
%      'iri'           = profiles are those generated by the IRI2016 model
%      'iri2016'       = profiles are those generated by the IRI2016 model
%      'iri2012'       = profiles are those generated by the IRI2012 model
%      'iri2007'       = profiles are those generated by the IRI2007 model
%      'firi'          = profiles are those generated by the IRI2016 model
%                        using the FIRI data for heights below 120 km, with
%                        interpolation between FIRI and IRI F layer
%      'chapman'       = profiles generated using IRI2016 layer parameters and
%                        Chapman layers
%      'chapman_fllhc' = as for 'chapman' but the FIRIC low latitude height
%                        correction has been applied
%
%   iri_options        - structure which specfies options for IRI2016 (see 
%                        iri2016.m for details). iri_options is ignored if a
%                        profile_type other than IRI2016 is specified.
%
% Outputs :
%   iono_pf_grid   - 2d grid (height vs ground range) of ionospheric plasma
%                      frequency (MHz)
%   iono_pf_grid_5 - 2d grid (height vs ground range) of ionospheric plasma
%                      frequency (MHz) 5 minutes later
%   collison_freq  - 2d grid (height vs ground range) of ionospheric
%                      collision frequencies
%   irreg          - 3 x num_ranges array of irregularity parameters as a
%                      function of ground range
%     irreg(1, :) = irregularity strength and is the ratio of irregular
%                     electron density to the background value - can be
%                     ignored (set to 0) if no_dop_spread
%     irreg(2, :) = magnetic dip angle at the phase screen height of
%                     irregularities (typically 300km) (degrees) - can be
%                     ignored (set to 0) if no_dop_spread
%     irreg(3, :) = magnetic declination at the phase screen height of
%                     irregularities (typically 300km) (degrees) - can be
%                     ignored (set to 0) if no_dop_spread
%     irreg(4, :) = square of frequency spread (Hz^2) per unit path length (Km)
%                     at a carrier frequency of 1MHz scaled by the electron
%                     density (electrons per cm^3) - can be ignored (set to 0)
%                     if no_dop_spread
%   iono_te_grid   - 2d grid (height vs ground range) of ionospheric electron
%                      temperature
%
% Notes:
%   1. If an iri2012 profile is requested, then iri2012 is called with the
%   B0 (thickness) and B1 (shape) parameters determined by Bil-2000 model.
%   See iri2012.m for further detail
%
%   2. If an iri2007 profile is requested, then iri2007 is called with the
%   following inputs: B0 - Table option, D-region model - IRI-1995. See
%   iri2007.m for further detail.
%
% Dependencies:
%   iri2016.mex
%   iri2012.mex
%   iri2007.mex
%   chapman.m
%
% Author:
%   V1.0  M.A. Cervera  21/11/2008
%     Initial Version
%
%   V1.1  M.A. Cervera  11/12/2009
%     Added ability to generate ionospheric height profiles in different ways
%
%   V1.2  M.A. Cervera  12/05/2009
%     Uses 'parfor' to parallelize the generation of the ionospheric
%     grids if the parallel computing tool box is available
%
%   V1.3  M.A. Cervera  12/09/2012
%     Now has option to use IRI2012.
%
%   V1.4  L.H.Pederick  16/11/2015
%     Added electron temperature to the output
%
%   V1.5  M.A. Cervera  02/05/2016
%     Now has option to use IRI2016.
%

function [iono_pf_grid, iono_pf_grid_5, collision_freq, irreg, ...
	 iono_te_grid] = ...
      gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, ...
                       max_range, num_range, range_inc, start_height, ...
                       height_inc, num_heights, kp, doppler_flag, ...
		       profile_type, varargin);
    
    re_eq = 6378137.0;                 % equatorial radius of Earth
    dtor = pi / 180.0d0;               % degrees to radians conversion
    pfsq_conv = 80.6163849431291e-12;  % mult. factor to convert elec density
                                       % in m^-3 to plasma freq squared in MHz^2
 
    % get the iri_options structure if it has been input
    if (length(varargin) > 0) 
      iri_options = varargin{1};
    else
      iri_options = struct;
    end
				       
    % make sure we have a valid profile type
    if (~exist('profile_type'))
        profile_type = 'iri';
    end
    if (~strcmp(lower(profile_type), 'chapman_fllhc') & ...
            ~strcmp(lower(profile_type), 'chapman') & ...
            ~strcmp(lower(profile_type), 'iri')  & ...
            ~strcmp(lower(profile_type), 'iri2007')  & ...
            ~strcmp(lower(profile_type), 'iri2012')  & ...
	    ~strcmp(lower(profile_type), 'iri2016')  & ...
            ~strcmp(lower(profile_type), 'firi') )
        error('invalid profile type')
        return
    end
    fllhc_flag = 0;
    if (strcmp(lower(profile_type), 'chapman_fllhc'))
        profile_type = 'chapman';
        fllhc_flag = 1;
    end
    
    % array of heights (km)
    height_arr = [0:num_heights-1].*height_inc+start_height;
    
    % initialize arrays
    iono_parms = zeros(15, num_range) .* NaN;
    iono_pf_grid = zeros(num_heights, num_range) .* NaN;
    iono_pf_grid_5 = zeros(num_heights, num_range) .* NaN;
    iono_te_grid = zeros(num_heights, num_range) .* NaN;
    collision_freq = zeros(num_heights, num_range) .* NaN;
    irreg = zeros(4, num_range) .* NaN;
    
    % convert geodetic origin_lat and origin_lon to lat and lon on a spherical
    % surface of radius 6378137 m (equatorial radius of Earth) directly above
    % the origin
    re_wgs84 = earth_radius_wgs84(origin_lat);
    ht = re_eq - re_wgs84;
    origin_lat_gc = wgs842gc_lat(origin_lat, ht);
    origin_lon_gc = origin_lon;
    
    % loop over range where range is arc length measured on a spherical surface
    % of radius equal to the Earth's equatorial radius
    %   parfor rng = 1:num_range
    parfor rng = 1:num_range
        
        % convert range and azimuth to geodetic lat, lon
        range = (rng - 1) .* range_inc;
        [lat_gc, lon_gc] = raz2latlon(range*1000, azim, origin_lat_gc, ...
            origin_lon_gc);
        
        xcart = re_eq .* cos(lat_gc * dtor) * cos(lon_gc * dtor);
        ycart = re_eq .* cos(lat_gc * dtor) * sin(lon_gc * dtor);
        zcart = re_eq .* sin(lat_gc * dtor);
        [lat, lon] = wgs84_xyz2llh(xcart, ycart, zcart);
        
        % generate the ionospheric profile
        [iono_pf_prof, iono_pf_prof5, iono_extra, iono_te_prof] = ...
	    gen_iono_profile(lat, lon, num_heights, start_height, ...
	                     height_inc, origin_lat_gc, origin_lon_gc, ...
			     UT, R12, profile_type, iri_options, ...
	                     doppler_flag, fllhc_flag);

        iono_pf_grid(:, rng) = iono_pf_prof;
        iono_pf_grid_5(:, rng) = iono_pf_prof5;
        iono_te_grid(:, rng) = iono_te_prof;
	
        % generate collision frequency grid
        foE = sqrt(iono_extra(5) .* pfsq_conv);  % Critical freq of E Layer(MHz)
        collision_freq(:, rng) = 4 .* foE.^4 + ...
            1000 .* exp(-(height_arr - 140) ./ 20);
       
        % call dop_spread_eq to generate doppler spread due to traversing the
        % equatorial region - we need to determine the R12 index to do this
	if doppler_flag
          dop_spread = dop_spread_eq(lat, lon, UT, R12);
	else
	  dop_spread = 0;
	end
       
        % call geomag field routine at phase screen height of irregularities
        long = lon;
        if (long < 0) long = long + 360; end
        mag_field = igrf2016(lat, lon, UT, 300);
        dip = mag_field(8);
        dec = mag_field(10);
        
        % generate the irregularity strength - call irreg_strength
        strength = irreg_strength(lat, lon, UT, kp);
	
	% fill the irregularities parameter array
        irreg_parms = [strength, dip, dec, dop_spread];
        irreg(:, rng) = irreg_parms;
        
    end
    
    return
end




%
% subfunction which generates ionospheric plasma frequency height profile at
% a given input latitude and longitude
%
function [iono_pf_prof, iono_pf_prof5, iono_extra, iono_te_prof] = ...
      gen_iono_profile(lat, lon, num_heights, start_height, height_inc, ...
                       origin_lat_gc, origin_lon_gc, UT, R12, ...
		       profile_type, iri_options, doppler_flag, fllhc_flag);
    
    re_eq = 6378137.0;                 % equatorial radius of Earth
    dtor = pi / 180.0d0;               % degrees to radians conversion
    pfsq_conv = 80.6163849431291e-12;  % mult. factor to convert elec. density
    
    
    % UT 5 minutes later
    UT_5 = UT + [0 0 0 0 5];
    if (UT_5(5) > 59)
        UT_5(5) = UT_5(5) - 60;
        UT_5(4) = UT_5(4) + 1;
        if (UT_5(4) > 23) UT_5(4) = 0; end
    end
    
    if strcmp(lower(profile_type), 'chapman')
        
        ht_max = start_height + height_inc .* (num_heights - 1);
        height_arr = [start_height : height_inc : ht_max];
        
        % calculate the solar zenith angle at UT and 5 minutes later
        sol_zen_ang = solar_za(lat, lon, UT);
        sol_zen_ang_5 = solar_za(lat, lon, UT_5);
        
        % Generate the plasma frequency arrays at time UT and UT + 5min. Call
        % iri2012 at time UT and 5 minutes later. IRI only returns 100
        % values heights - so determine the number of multiple calls required.
        
        % call IRI 2016
        [iono, iono_extra] = iri2016(lat, lon, R12, UT);
        
        % get the IRI iono parameters
        foE = sqrt(iono_extra(5) .* pfsq_conv);
        hmE = iono_extra(6);
        foF1 = sqrt(iono_extra(3) .* pfsq_conv);
        hmF1 = iono_extra(4);
        foF2 = sqrt(iono_extra(1) .* pfsq_conv);
        hmF2 = iono_extra(2);
        
        % apply low latitude height correction to hmF2 a la firic if requested
        if fllhc_flag
            fac = exp(-(lat./35).^4);
            hmF2 = hmF2 .* (1 - fac) + fac.*hmF2.*(1 + 0.0015.*(hmF2-300));
        end
        
        % generate the layer thicknesses
        ymE = 20.0;
        ymF1 = hmF1 ./ 4;
        ymF2 = (0.15 .* exp(-(sol_zen_ang./105).^4) + 0.25 ) .* hmF2;
        
        % generate iono profile
        plasma_freq = chapman(foE, hmE, ymE, foF1, hmF1, ymF1, foF2, ...
            hmF2, ymF2, height_arr);
        
        if doppler_flag
            [iono5, iono_extra5] = iri2016(lat, lon, R12, UT_5)
            foE = sqrt(iono_extra5(5) .* pfsq_conv);
            hmE = iono_extra5(6);
            ymE = 20.0;
            foF1 = sqrt(iono_extra5(3) .* pfsq_conv);
            hmF1 = iono_extra5(4);
            ymF1 = hmF1 ./ 4;
            foF2 = sqrt(iono_extra5(1) .* pfsq_conv);
            hmF2 = iono_extra5(2);
            if fllhc_flag
                fac = exp(-(lat./35).^4);
                hmF2 = hmF2 .* (1 - fac) + fac.*hmF2.*(1 + 0.0015.*(hmF2-300));
            end
            ymF2 = (0.15 .* exp(-(sol_zen_ang_5./105).^4) + 0.25 ) .* hmF2;
            plasma_freq5 = chapman(foE, hmE, ymE, foF1, hmF1, ymF1, foF2, ...
                hmF2, ymF2, height_arr);
        end
        
        % calculate plasma frequency (MHz) profile and fill the array
        iono_pf_prof = plasma_freq;
        if doppler_flag
            iono_pf_prof5 = plasma_freq5;
        else
            iono_pf_prof5 = plasma_freq;
        end
        
	iono_te_prof = NaN(size(iono_pf_prof));
	
    elseif (strcmp(lower(profile_type), 'iri') | ...
            strcmp(lower(profile_type), 'iri2016') | ...
            strcmp(lower(profile_type), 'firi') )
        
        firi_flag = strcmp(lower(profile_type), 'firi');
        
        if (firi_flag)
            % call IRI 2016, with FIRI option on
            [iono, iono_extra] = iri2016_firi_interp(lat, lon, R12, UT, ...
		start_height, height_inc, num_heights, iri_options);
            
            if doppler_flag
                [iono5, iono_extra5] = iri2016_firi_interp(lat, lon, R12, ...
		    UT_5, start_height, height_inc, num_heights, iri_options);
            end
            
            
        else
            % call IRI 2016	    
            [iono, iono_extra] = iri2016(lat, lon, R12, UT, start_height, ...
                height_inc, num_heights, iri_options);
	   
            if doppler_flag
                [iono5, iono_extra5] = iri2016(lat, lon, R12, UT_5, ...
		    start_height, height_inc, num_heights, iri_options);
            end
        end
        
        % get the electron density (Num electrons per m^3)
        elec_dens = iono(1, :);
        idx_neg = find(elec_dens == -1);
        elec_dens(idx_neg) = 0;
        
        if doppler_flag
            elec_dens5 = iono5(1, :);
            idx_neg = find(elec_dens5 == -1);
            elec_dens5(idx_neg) = 0;
        end
        
	% get the electron temperature profile - set bad values to 300
	iono_te_prof = iono(4, :);
        idx_neg = find(iono_te_prof == -1);
        iono_te_prof(idx_neg) = 300;

	
        % calculate plasma frequency (MHz) profile and fill the array
        iono_pf_prof = sqrt(elec_dens .* pfsq_conv);     % (MHz)
        if doppler_flag
            iono_pf_prof5 = sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
        else
            iono_pf_prof5 = sqrt(elec_dens .* pfsq_conv);
        end
      
    elseif (strcmp(lower(profile_type), 'iri2012') )
        
        % call IRI 2012	   
        [iono, iono_extra] = iri2012(lat, lon, R12, UT, start_height, ...
                 height_inc, num_heights);
        if doppler_flag
            [iono5, iono_extra5] = iri2012(lat, lon, R12, UT_5, ...
		    start_height, height_inc, num_heights);
        end
        
        % get the electron density (Num electrons per m^3)
        elec_dens = iono(1, :);
        idx_neg = find(elec_dens == -1);
        elec_dens(idx_neg) = 0;
        
        if doppler_flag
            elec_dens5 = iono5(1, :);
            idx_neg = find(elec_dens5 == -1);
            elec_dens5(idx_neg) = 0;
        end
        
        % get the electron temperature profile - set bad values to 300
	iono_te_prof = iono(4, :);
        idx_neg = find(iono_te_prof == -1);
        iono_te_prof(idx_neg) = 300;

        % calculate plasma frequency (MHz) profile and fill the array
        iono_pf_prof = sqrt(elec_dens .* pfsq_conv);     % (MHz)
        if doppler_flag
            iono_pf_prof5 = sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
        else
            iono_pf_prof5 = sqrt(elec_dens .* pfsq_conv);
        end
      
    elseif strcmp(lower(profile_type), 'iri2007')
        
        % IRI2007 only returns 100 values for electron density with height - so
        % determine the number of  multiple calls required.
        max_iri_numhts = 100;
        num_iri_calls = ceil(num_heights ./ max_iri_numhts);
        for ii = 1:num_iri_calls
            % call IRI 2007
            height_start = start_height + (ii - 1) .* max_iri_numhts .* ...
		height_inc;
            [iono, iono_extra] = iri2007(lat, lon, R12, UT, height_start, ...
                height_inc);
            
            if doppler_flag
                [iono5, iono_extra5] = iri2007(lat, lon, R12, UT_5, ...
                    height_start, height_inc);
            end
            
            % get the electron density (Num electrons per m^3)
            remaining_heights = num_heights - (ii - 1)*max_iri_numhts;
            idx_end = min([remaining_heights max_iri_numhts]);
            
            elec_dens = iono(1, 1:idx_end);
            idx_neg = find(elec_dens == -1);
            elec_dens(idx_neg) = 0;
            
            if doppler_flag
                elec_dens5 = iono5(1, 1:idx_end);
                idx_neg = find(elec_dens5 == -1);
                elec_dens5(idx_neg) = 0;
            end
            
	    % get the electron temperature profile - set bad values to 300
            elec_temp = iono(4, 1:idx_end);
            idx_neg = find(elec_temp == -1);
            elec_temp(idx_neg) = 300;

            % calculate plasma frequency (MHz) profile and fill the array
            idx = [(ii - 1)*max_iri_numhts + 1 :  ...
                ii*max_iri_numhts - (max_iri_numhts - idx_end)];
            iono_pf_prof(idx) = sqrt(elec_dens .* pfsq_conv);     % (MHz)
            if doppler_flag
              iono_pf_prof5(idx) = sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
            else
              iono_pf_prof5(idx) = sqrt(elec_dens .* pfsq_conv);
	    end
	    iono_te_prof(idx) = elec_temp;
        end
        
    end
   
    return
end


